<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>AgenticVerifier Conversation Viewer (Static)</title>
    <style>
        :root {
            --bg: #0f1117;
            --panel: #151822;
            --text: #e6e6e6;
            --muted: #a0a0a0;
            --accent: #5b8cff;
            --border: #2a2f3f;
        }
        html, body { height: 100%; }
        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        }
        .layout { display: flex; flex-direction: column; height: 100%; }
        .content { flex: 1; display: grid; grid-template-rows: auto 1fr; height: 100%; }
        .topbar { display: flex; gap: 12px; align-items: center; padding: 12px 16px; border-bottom: 1px solid var(--border); }
        .title { font-size: 18px; font-weight: 600; }
        .muted { color: var(--muted); }
        .main { display: grid; grid-template-columns: 1fr; height: 100%; }
        .panel { border-right: 1px solid var(--border); overflow: auto; }
        .panel h3 { font-size: 14px; margin: 16px; color: var(--muted); font-weight: 600; }
        .rounds { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; padding: 0 16px 24px; }
        .round { background: #0f1320; border: 1px solid var(--border); border-radius: 8px; overflow: hidden; cursor: pointer; }
        .round img { width: 100%; display: block; aspect-ratio: 1 / 1; object-fit: cover; }
        .round .label { padding: 8px; font-size: 12px; color: var(--muted); }
        .detail { overflow: auto; }
        .section { padding: 16px; border-bottom: 1px solid var(--border); }
        .section h4 { margin: 0 0 10px; font-size: 14px; color: var(--muted); }
        .imgwrap { background: #0b0e18; border: 1px solid var(--border); border-radius: 8px; padding: 8px; }
        .imgwrap img { width: 100%; height: auto; display: block; }
        pre, code {
            background: #0b0e18;
            color: #d7e1ff;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            overflow: visible;
            white-space: pre-wrap;
            word-break: break-word;
        }
        .msg.tool {
            border-color: #ffb347;
            box-shadow: 0 0 0 2px rgba(255, 179, 71, 0.25) inset;
            background: rgba(255, 179, 71, 0.08);
        }
        .msg.tool .meta {
            color: #ffd399;
        }
        .msg.tool .meta strong {
            color: #ffb347;
        }
        .row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        .note { padding: 10px 12px; background: #0b0e18; border: 1px dashed var(--border); border-radius: 8px; color: var(--muted); }
        a { color: var(--accent); }
        .small { font-size: 12px; }
        @media (max-width: 1200px) { .main { grid-template-columns: 1fr; } .panel { border-right: none; border-bottom: 1px solid var(--border); } }
        /* Conversation message styles (adapted from web/templates/index.html) */
        #generator_list { display: flex; flex-direction: column; gap: 12px; }
        .msg { border: 1px solid var(--border); border-radius: 8px; background: #0b0e18; padding: 12px; }
        .msg .meta { margin-bottom: 6px; color: var(--muted); font-size: 12px; }
        .bubble { font-size: 14px; line-height: 1.5; color: var(--text); }
        .bubble img { max-width: 100%; height: auto; display: block; margin: 6px 0; border-radius: 6px; }
        .tool-calls { margin-top: 8px; border-top: 1px dashed var(--border); padding-top: 8px; }
        .tool-calls > .title { font-weight: 600; font-size: 12px; color: var(--muted); margin-bottom: 6px; }
        .tool-call { border: 1px solid var(--border); border-radius: 6px; background: #0f1320; padding: 8px; margin-bottom: 8px; }
        .tool-call .tool-head { font-weight: 600; font-size: 13px; color: var(--text); margin-bottom: 6px; }
    </style>
    <script>
        // Configure datasets here. Use paths relative to the repository root as served by GitHub Pages.
        let DATASETS = [];
        const DATA_ROOT = "output/blendergym/20251101_085308";

        const MAX_PROBE_ROUNDS = 300; // upper bound for probing rounds

        function qs(sel, root=document) { return root.querySelector(sel); }
        function qsa(sel, root=document) { return Array.from(root.querySelectorAll(sel)); }

        function getQueryInt(name, defVal) {
            const u = new URL(window.location.href);
            const s = u.searchParams.get(name);
            const v = parseInt(s || "");
            return Number.isFinite(v) ? v : defVal;
        }

        function setQuery(name, value) {
            const u = new URL(window.location.href);
            u.searchParams.set(name, String(value));
            window.history.replaceState({}, "", u.toString());
        }

        async function fetchJson(url) {
            try {
                const res = await fetch(url, { cache: "no-store" });
                if (!res.ok) return null;
                return await res.json();
            } catch (e) {
                return null;
            }
        }

        async function listDatasetDirectories(rootPath) {
            const normalizedRoot = (rootPath || "").replace(/\\/g, "/").replace(/\/+$/, "") + "/";
            try {
                const res = await fetch(normalizedRoot, { cache: "no-store" });
                if (!res.ok) return [];
                const body = await res.text();
                const trimmed = body.trim();
                const dirSet = new Set();
                let parsed = null;
                if (trimmed.startsWith("[") || trimmed.startsWith("{")) {
                    try {
                        parsed = JSON.parse(trimmed);
                    } catch (err) {
                        parsed = null;
                    }
                }
                if (parsed) {
                    const candidates = Array.isArray(parsed)
                        ? parsed
                        : Array.isArray(parsed.directories)
                            ? parsed.directories
                            : [];
                    candidates.forEach((entry) => {
                        if (typeof entry === "string" && entry.trim()) {
                            const cleaned = entry.trim().replace(/\/+$/, "");
                            if (cleaned && !cleaned.includes(".")) dirSet.add(cleaned);
                        }
                    });
                } else {
                    try {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(body, "text/html");
                        const anchors = Array.from(doc.querySelectorAll('a[href]'));
                        anchors.forEach((a) => {
                            let href = a.getAttribute('href') || "";
                            if (!href || href.startsWith("../")) return;
                            href = href.split("?")[0].split("#")[0];
                            if (!href) return;
                            if (href.toLowerCase().startsWith("http")) return;
                            href = href.replace(/\/+$/, "");
                            if (!href) return;
                            if (href.includes("/")) {
                                href = href.split("/")[0];
                            }
                            if (!href || href === "." || href === "..") return;
                            if (href.includes(".")) return;
                            dirSet.add(href);
                        });
                    } catch (err) {
                        return [];
                    }
                }
                return Array.from(dirSet).sort().map((name) => normalizedRoot + name);
            } catch (e) {
                return [];
            }
        }

        async function loadDatasets() {
            const dirs = await listDatasetDirectories(DATA_ROOT);
            DATASETS = dirs;
            return DATASETS;
        }

        function inferDatasetLabel(path) {
            const parts = path.split("/output/");
            return parts.length > 1 ? parts[1] : path;
        }

        // ---- Conversation helpers (ported from web/templates/index.html, adapted for static) ----
        function renderTextWithImages(text) {
            if (!text) return '';
            let html = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            html = html.replace(/!\[[^\]]*\]\(([^)]+)\)/g, (m, p1) => {
                const src = p1.trim();
                return '<img src="' + src + '" alt="image" />';
            });
            html = html.replace(/\n/g, '<br/>');
            return html;
        }

        function tryParseJson(maybeJson) {
            if (maybeJson == null) return null;
            if (typeof maybeJson === 'object') return maybeJson;
            if (typeof maybeJson !== 'string') return null;
            try { return JSON.parse(maybeJson); } catch { return null; }
        }

        function normalizeImageUrl(imageUrl) {
            if (!imageUrl) return null;
            let url = imageUrl;
            if (typeof imageUrl === 'object' && imageUrl.url) url = imageUrl.url;
            if (!url) return null;
            return url; // In static mode, assume paths are already relative to dataset root
        }

        function normalizeToolCalls(msg) {
            const calls = [];
            if (!msg) return calls;
            if (Array.isArray(msg.tool_calls)) {
                msg.tool_calls.forEach((tc) => {
                    if (!tc) return;
                    if (tc.function && (tc.function.name || tc.function.arguments != null)) {
                        calls.push({ name: tc.function.name || 'function', id: tc.id || null, arguments: tc.function.arguments });
                    } else if (tc.type && tc.name) {
                        calls.push({ name: tc.name, id: tc.id || null, arguments: tc.arguments || tc.args || null });
                    }
                });
            }
            if (!calls.length && (msg.tool_call || msg.tool_name)) {
                calls.push({ name: msg.tool_name || 'tool', id: msg.tool_call_id || null, arguments: msg.tool_call_arguments || msg.arguments || null });
            }
            return calls;
        }

        function renderToolCallsSection(msg) {
            const calls = normalizeToolCalls(msg);
            if (!calls.length) return null;
            const wrapper = document.createElement('div');
            wrapper.className = 'tool-calls';
            const title = document.createElement('div');
            title.className = 'title';
            title.textContent = 'Tool calls';
            wrapper.appendChild(title);
            calls.forEach((call) => {
                const item = document.createElement('div');
                item.className = 'tool-call';
                const head = document.createElement('div');
                head.className = 'tool-head';
                const label = call.name ? call.name : 'tool';
                head.textContent = label + (call.id ? ('  [' + call.id + ']') : '');
                item.appendChild(head);
                const pre = document.createElement('pre');
                const parsed = tryParseJson(call.arguments);
                try {
                    pre.textContent = parsed != null ? JSON.stringify(parsed, null, 2) : String(call.arguments ?? '');
                } catch {
                    pre.textContent = String(call.arguments ?? '');
                }
                item.appendChild(pre);
                wrapper.appendChild(item);
            });
            return wrapper;
        }

        function renderMessageContent(msg) {
            const container = document.createElement('div');
            container.className = 'bubble';
            const content = msg && (msg.content || msg.text || msg.message);
            if (Array.isArray(content)) {
                content.forEach(part => {
                    if (!part) return;
                    if (part.type === 'text' || typeof part === 'string') {
                        const div = document.createElement('div');
                        div.innerHTML = renderTextWithImages(String(part.text || part));
                        container.appendChild(div);
                    } else if (part.type === 'image_url' || part.image_url) {
                        const src = normalizeImageUrl(part.image_url || part.url);
                        if (src) {
                            const img = document.createElement('img');
                            img.src = src;
                            img.alt = 'image';
                            img.style.maxWidth = '100%';
                            container.appendChild(img);
                        }
                    }
                });
            } else if (content && typeof content === 'object') {
                if (content.image_url || content.images) {
                    const maybeUrls = [];
                    if (content.image_url) maybeUrls.push(content.image_url);
                    if (Array.isArray(content.images)) maybeUrls.push(...content.images);
                    maybeUrls.forEach(u => {
                        const src = normalizeImageUrl(u);
                        if (src) {
                            const img = document.createElement('img');
                            img.src = src;
                            img.alt = 'image';
                            img.style.maxWidth = '100%';
                            container.appendChild(img);
                        }
                    });
                }
                if (content.text) {
                    const div = document.createElement('div');
                    div.innerHTML = renderTextWithImages(String(content.text));
                    container.appendChild(div);
                }
            } else {
                const div = document.createElement('div');
                div.innerHTML = renderTextWithImages(String(content || ''));
                container.appendChild(div);
            }
            const role = msg && (msg.role || msg.speaker || msg.name);
            if (role && String(role).toLowerCase() === 'assistant') {
                const toolsEl = renderToolCallsSection(msg);
                if (toolsEl) container.appendChild(toolsEl);
            }
            return container;
        }

        function tryGetMessages(generatorJson) {
            if (!generatorJson) return [];
            if (Array.isArray(generatorJson)) return generatorJson;
            if (Array.isArray(generatorJson.messages)) return generatorJson.messages;
            if (Array.isArray(generatorJson.conversation)) return generatorJson.conversation;
            return [];
        }

        function renderGeneratorConversation(gen) {
            const messages = tryGetMessages(gen);
            const list = qs('#generator_list');
            const fallback = qs('#generator_json');
            list.innerHTML = '';
            if (messages.length > 0) {
                fallback.style.display = 'none';
                messages.forEach((msg) => {
                    const role = (msg && (msg.role || msg.speaker || msg.name)) || 'message';
                    const roleLower = String(role).toLowerCase();
                    const item = document.createElement('div');
                    item.className = 'msg' + (roleLower === 'tool' ? ' tool' : '');
                    const header = document.createElement('div');
                    header.className = 'meta' + (roleLower === 'tool' ? ' tool' : '');
                    header.innerHTML = '<strong>' + role + '</strong>';
                    item.appendChild(header);
                    item.appendChild(renderMessageContent(msg));
                    list.appendChild(item);
                });
            } else {
                fallback.style.display = 'block';
                try { fallback.textContent = JSON.stringify(gen, null, 2); } catch { fallback.textContent = '(no generator_memory.json)'; }
            }
        }

        async function renderApp() {
            const list = qs('#generator_list');
            const fallback = qs('#generator_json');
            if (!DATASETS.length) {
                if (list) list.innerHTML = '';
                if (fallback) {
                    fallback.style.display = 'block';
                    fallback.textContent = `No datasets found under ${DATA_ROOT}`;
                }
                const titleEl = qs('.title');
                if (titleEl) titleEl.textContent = 'Dataset: (none)';
                return;
            }

            const selectedIdx = Math.min(Math.max(getQueryInt('dataset', 1), 1), DATASETS.length) - 1;
            const root = DATASETS[selectedIdx];
            const titleEl = qs('.title');
            if (titleEl) titleEl.textContent = `Dataset: ${inferDatasetLabel(root)}`;
            setQuery('dataset', selectedIdx + 1);

            const gen = await fetchJson(`${root}/generator_memory.json`);
            if (gen) {
                renderGeneratorConversation(gen);
            } else if (fallback) {
                fallback.style.display = 'block';
                fallback.textContent = '(generator_memory.json not found)';
            }
        }

        window.addEventListener('DOMContentLoaded', async () => {
            await loadDatasets();
            await renderApp();
        });
    </script>
    <!-- Optional: favicon -->
</head>
<body>
    <div class="layout">
        <div class="content">
            <div class="topbar">
                <div class="title"></div>
            </div>
            <div class="main">
                <div class="detail">
                    <div class="section">
                        <h4>Conversation</h4>
                        <div id="generator_list"></div>
                        <pre id="generator_json"></pre>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
<!--
To host on GitHub Pages:
1) Commit this file and your output folders to the repository.
2) Enable Pages for the repository (Settings â†’ Pages) and set the branch/folder.
3) Visit https://<USER>.github.io/<REPO>/web/index.html
4) Adjust DATASETS paths above to match where your outputs live in the repo.
-->
</html>


